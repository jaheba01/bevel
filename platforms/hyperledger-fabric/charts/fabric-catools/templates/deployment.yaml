##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ template "fabric-catools.name" . }}
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Release.Name }}
    app.kubernetes.io/name: {{ include "fabric-catools.name" . }}
    app.kubernetes.io/component: ca-tools
    app.kubernetes.io/part-of: {{ include "fabric-catools.fullname" . }}
    app.kubernetes.io/namespace: {{ .Release.Namespace }}
    app.kubernetes.io/release: {{ .Release.Name }}
    app.kubernetes.io/managed-by: helm
  annotations:
    {{ include "labels.deployment" . | nindent 2 }} 
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ .Release.Name }}
      app.kubernetes.io/name: {{ include "fabric-catools.name" . }}
      app.kubernetes.io/component: ca-tools
      app.kubernetes.io/part-of: {{ include "fabric-catools.fullname" . }}
      app.kubernetes.io/namespace: {{ .Release.Namespace }}
      app.kubernetes.io/release: {{ .Release.Name }}
      app.kubernetes.io/managed-by: helm
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}
        app.kubernetes.io/name: {{ include "fabric-catools.name" . }}
        app.kubernetes.io/component: ca-tools
        app.kubernetes.io/part-of: {{ include "fabric-catools.fullname" . }}
        app.kubernetes.io/namespace: {{ .Release.Namespace }}
        app.kubernetes.io/release: {{ .Release.Name }}
        app.kubernetes.io/managed-by: helm
        {{ include "labels.deployment" . | nindent 6 }}  
    spec:
      serviceAccountName: {{ $.Values.global.serviceAccountName }}
      {{- if .Values.global.vault.imageSecretName }}
      imagePullSecrets:
        - name: {{ $.Values.global.vault.imageSecretName }}
      {{- end }}
      volumes:
      - name: ca-tools-pv
        persistentVolumeClaim:
          claimName: ca-tools-pvc
      - name: ca-tools-crypto-pv
        persistentVolumeClaim:
          claimName: ca-tools-crypto-pvc
      - name: certcheck
        emptyDir:
          medium: Memory
      - name: generate-crypto
        configMap:
          name: crypto-scripts-cm
          defaultMode: 0775
          items:
            - key: generate-crypto-orderer.sh
              path: generate-crypto-orderer.sh
      - name: generate-orderer-crypto
        configMap:
          name: crypto-scripts-cm
          defaultMode: 0775
          items:
            - key: orderer-script.sh
              path: orderer-script.sh
      - name: generate-crypto-peer
        configMap:
          name: crypto-scripts-cm
          defaultMode: 0775
          items:
            - key: generate-crypto-peer.sh
              path: generate-crypto-peer.sh
      - name: generate-crypto-add-peer
        configMap:
          name: crypto-scripts-cm
          defaultMode: 0775
          items:
            - key: generate-crypto-add-peer.sh
              path: generate-crypto-add-peer.sh
      - name: generate-user-crypto
        configMap:
          name: crypto-scripts-cm
          defaultMode: 0775
          items:
            - key: generate-user-crypto.sh
              path: generate-user-crypto.sh
      - name: store-vault-orderer
        configMap:
          name: orderer-script-store-vault
          defaultMode: 0775
          items:
            - key: store-vault-orderer.sh
              path: store-vault-orderer.sh
      - name: store-vault-peer
        configMap:
          name: peer-script-store-vault
          defaultMode: 0775
          items:
            - key: store-vault-peer.sh
              path: store-vault-peer.sh
      - name: store-vault-users
        configMap:
          name: users-script-store-vault
          defaultMode: 0775
          items:
            - key: store-vault-users.sh
              path: store-vault-users.sh     
      - name: none-config
        configMap:
          name: msp-config-file
          defaultMode: 0775
          items:
            - key: none-config.yaml
              path: none-config.yaml
      - name: no-none-config
        configMap:
          name: msp-config-file
          defaultMode: 0775
          items:
            - key: no-none-config.yaml
              path: no-none-config.yaml
      {{- $file := .Files.Get "files/orderer.crt" }}
      {{ if and (eq $.Values.orgData.type "peer") $file }}
      - name: orderer-tls-cacert
        configMap:
          name: orderer-tls-cacert
          defaultMode: 0775
          items:
            - key: orderer.crt
              path: orderer.crt
      {{- end }}
      - name: scripts-volume
        configMap:
          name: bevel-vault-script
      - name: package-manager
        configMap:
          name: package-manager
      initContainers:
        - name: init-check-certificates
          image: {{ $.Values.image.alpineUtils }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          env:
          - name: VAULT_ADDR
            value: {{ $.Values.global.vault.address }}
          - name: VAULT_APP_ROLE
            value: {{ $.Values.global.vault.role }}
          - name: KUBERNETES_AUTH_PATH
            value: {{ $.Values.global.vault.authPath }}
          - name: VAULT_TYPE
            value: {{ $.Values.global.vault.type }}
          - name: VAULT_SECRET_ENGINE
            value: "{{ .Values.global.vault.secretEngine }}"
          - name: VAULT_SECRET_PREFIX
            value: "{{ .Values.global.vault.secretPrefix }}"
          - name: COMPONENT_TYPE
            value: "{{ $.Values.orgData.type }}"
          - name: COMPONENT_NAME
            value: {{ .Release.Namespace }}
          - name: ORG_NAME_EXT
            value: {{ $.Values.orgData.orgName }}
          - name: PROXY
            value: {{ .Values.global.proxy.provider }}
          - name: ORDERERS_NAMES
            value: "{{ $.Values.orderers | join " " -}}"
          - name: PEERS_NAMES
            value: "{{ $.Values.peers | join " " -}}"
          - name: USERS_IDENTITIES
            value: "{{ $.Values.users.usersIdentities | join " " -}}"
          - name: MOUNT_PATH
            value: "/certcheck"
          command: ["sh", "-c"]
          args:
            - |-
              #!/usr/bin/env sh

              mkdir -p ${MOUNT_PATH}
              OUTPUT_PATH="/crypto-config/${COMPONENT_TYPE}Organizations/${COMPONENT_NAME}"
              mkdir -p ${OUTPUT_PATH}/ca
              mkdir -p /root/ca-tools/${ORG_NAME_EXT}
              
{{- if eq .Values.global.vault.type "hashicorp" }}
              . /scripts/bevel-vault.sh
              # Calling a function to retrieve the vault token.
              vaultBevelFunc "init"

              vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/ca"

              # Get ca cert
              ca_cert=$(echo ${VAULT_SECRET} | jq -r ".[\"ca.${COMPONENT_NAME}-cert.pem\"]")
              echo "${ca_cert}" > ${OUTPUT_PATH}/ca/ca.${COMPONENT_NAME}-cert.pem

              # Get ca key
              ca_key=$(echo ${VAULT_SECRET} | jq -r ".[\"${COMPONENT_NAME}-CA.key\"]")
              echo "${ca_key}" > ${OUTPUT_PATH}/ca/${COMPONENT_NAME}-CA.key

              function checkSecret {
                key=$1
                key_formatted=$(echo $key | tr - /)
                file_name=$2
                vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/${key_formatted}"
                if [ "$SECRETS_AVAILABLE" == "yes" ]
                then
                  echo "Certificates present in vault"
                  touch ${MOUNT_PATH}/present_${file_name}.txt
                else
                  echo "Certficates absent in vault. Ignore error warning."
                  touch ${MOUNT_PATH}/absent_${file_name}.txt
                fi
              }
{{- else }} 

              kubectl get secret ca-certs --namespace {{ .Release.Namespace }} --output="jsonpath={.data.ca-${COMPONENT_NAME}-cert}" | base64 -d > ${OUTPUT_PATH}/ca/ca.${COMPONENT_NAME}-cert.pem
              kubectl get secret ca-certs --namespace {{ .Release.Namespace }} --output="jsonpath={.data.ca-${COMPONENT_NAME}-key}" | base64 -d > ${OUTPUT_PATH}/ca/${COMPONENT_NAME}-CA.key

              function checkSecret {
                key=$1
                file_name=$2
                kubectl get secret ${key} --namespace ${COMPONENT_NAME} -o json > /dev/null 2>&1
                if [ $? -ne 0 ]; then
                  echo "Certficates absent in kuberenetes secrets. Ignore error warning."
                  touch ${MOUNT_PATH}/absent_${file_name}.txt
                 else
                  echo "Certficates present in kuberenetes secrets. Ignore error warning."
                  touch ${MOUNT_PATH}/present_${file_name}.txt
                fi
              }
{{- end }}                 

              checkSecret admin-msp msp
              checkSecret admin-tls tls

              if [ "$COMPONENT_TYPE" = "orderer" ]; then
                SERVICES_NAMES=$ORDERERS_NAMES;
              fi;

              if [ "$COMPONENT_TYPE" = "peer" ]; then
                SERVICES_NAMES=$PEERS_NAMES;
              fi;

              for SERVICE in $SERVICES_NAMES
              do
                # Check if orderer/peer msp already created
                if [ "$COMPONENT_TYPE" = "peer" ]; then
                  SERVICE_NAME="${SERVICE%%,*}"
                  checkSecret ${SERVICE_NAME}-msp msp_${SERVICE_NAME}
                fi;

                if [ "$COMPONENT_TYPE" = "orderer" ]; then
                  SERVICE_NAME="${SERVICE}"
                  checkSecret ${SERVICE_NAME}-msp msp_${SERVICE_NAME}
                fi;
               
                # Check if orderer/peer msp already created
                if [ "$COMPONENT_TYPE" = "peer" ]; then
                  SERVICE_NAME="${SERVICE%%,*}"
                  checkSecret ${SERVICE_NAME}-tls tls_${SERVICE_NAME}
                fi;

                if [ "$COMPONENT_TYPE" = "orderer" ]; then
                  SERVICE_NAME="${SERVICE}"
                  checkSecret ${SERVICE_NAME}-tls tls_${SERVICE_NAME}
                fi;

              done

              if [ $COMPONENT_TYPE == 'peer' ];
              then
                # Check if msp config file already created
                checkSecret msp-config config_file 
                checkSecret orderer-tls orderer_tls_cert     
              fi;

              if [ "$USERS_IDENTITIES" ]
              then
                for user_identity in $USERS_IDENTITIES
                do
                  # Check if users tls already created
                   checkSecret ${user_identity}-tls tls_${user_identity}
                  # Check if users msp already created for users
                  checkSecret ${user_identity}-msp msp_${user_identity}
                done
              fi
          volumeMounts:
          - name: ca-tools-pv
            mountPath: /root/ca-tools
          - name: ca-tools-crypto-pv
            mountPath: /crypto-config
          - name: certcheck
            mountPath: /certcheck
          - name: scripts-volume
            mountPath: /scripts/bevel-vault.sh
            subPath: bevel-vault.sh
      containers:
        - name: ca-tools
          image: "{{ .Values.image.caTools }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          env:
          - name: COMPONENT_TYPE
            value: {{ $.Values.orgData.type }}
          - name: COMPONENT_NAME
            value: {{ .Release.Namespace }}
          - name: ORG_NAME_EXT
            value: {{ $.Values.orgData.orgName }}
          - name: REFRESH_CERTS
            value: "{{ $.Values.checks.refreshCertValue }}"
          - name: ADD_PEER
            value: "{{ $.Values.checks.addPeerValue }}"
          - name: ORDERERS_NAMES
            value: "{{ $.Values.orderers | join " " -}}"
          - name: PEERS_NAMES
            value: "{{ $.Values.peers | join " " -}}"
          - name: PEERS_COUNT
            value: "{{ len $.Values.peers }}"
          - name: USERS
            value: {{ $.Values.users.usersList | toJson | b64enc }}
          - name: USERS_ANSIBLE
            value: {{ $.Values.users.usersListAnsible }}
          - name: USERS_IDENTITIES
            value: "{{ $.Values.users.usersIdentities | join " " -}}"
          - name: SUBJECT
            value: {{ .Values.orgData.componentSubject }}
          - name: CERT_SUBJECT
            value: {{ .Values.orgData.certSubject }}
          - name: CA_URL
            value: {{ .Release.Name }}.{{ .Release.Namespace }}:7054
          - name: EXTERNAL_URL_SUFFIX
            value: {{ .Values.global.proxy.externalUrlSuffix }}
          - name: PROXY
            value: {{ .Values.global.proxy.provider }}
          - name: MOUNT_PATH
            value: "/certcheck"          
          command: ["sh", "-c"]
          args:
            - |- 
              . /scripts/package-manager.sh
              # Define the packages to install
              packages_to_install="jq"
              install_packages "$packages_to_install"
              
              if [ "$COMPONENT_TYPE" = "orderer" ]; then
                if [ -e  ${MOUNT_PATH}/absent_msp.txt ]; then
                  ORG_CYPTO_FOLDER="/crypto-config/ordererOrganizations/${COMPONENT_NAME}/users/Admin@${COMPONENT_NAME}"
                  ORG_CYPTO_ORDERER_FOLDER="/crypto-config/ordererOrganizations/${COMPONENT_NAME}/orderers"

                  SK_NAME=$(find ${ORG_CYPTO_FOLDER}/msp/keystore/ -name "*_sk")
                  if [ -n "$SK_NAME" ]; then
                      rm ${ORG_CYPTO_FOLDER}/msp/keystore/*_sk
                      rm /root/ca-tools/${ORG_NAME_EXT}/admin/msp/keystore/*_sk
                      rm /root/ca-tools/${ORG_NAME_EXT}/admin/tls/keystore/*_sk
                  fi;

                  # Generate crypto material for organization orderers (admin)
                  cd /root/ca-tools/${ORG_NAME_EXT} 
                  ./generate-crypto-orderer.sh          
                fi;

                # Generate crypto material for organization orderers (for each orderer)
                for ORDERER_NAME in $ORDERERS_NAMES
                do
                  if [ -e  ${MOUNT_PATH}/absent_msp_${ORDERER_NAME}.txt ]; then
                      echo "need to execute scripts for ${ORDERER_NAME}"
                      SK_NAME=$(find ${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/keystore/ -name "*_sk")
                      if [ -n "$SK_NAME" ]; then
                          rm  ${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/keystore/*_sk
                          rm /root/ca-tools/${ORG_NAME_EXT}/cas/orderers/msp/keystore/*_sk
                          rm /root/ca-tools/${ORG_NAME_EXT}/cas/orderers/tls/keystore/*_sk
                      fi;
                      cd /root/ca-tools/${ORG_NAME_EXT} 
                      ./orderer-script.sh ${ORDERER_NAME}                                
                  fi;
                done
              fi;

              if [ "$COMPONENT_TYPE" = "peer" ]; then
              
                for PEER in $PEERS_NAMES
                do
                  PEER_NAME="${PEER%%,*}"

                  if [ -e  ${MOUNT_PATH}/absent_msp.txt ] || [ -e ${MOUNT_PATH}/absent_msp_${PEER_NAME}.txt ] || [ "$REFRESH_CERTS" = "true" ]; then

                    ORG_CYPTO_FOLDER="/crypto-config/peerOrganizations/${COMPONENT_NAME}/users/Admin@${COMPONENT_NAME}"
                
                    SK_NAME=$(find ${ORG_CYPTO_FOLDER}/msp/keystore/ -name "*_sk")
                    if [ -n "$SK_NAME" ]; then
                        rm ${ORG_CYPTO_FOLDER}/msp/keystore/*_sk
                        rm /root/ca-tools/${ORG_NAME_EXT}/admin/msp/keystore/*_sk
                        rm /root/ca-tools/${ORG_NAME_EXT}/admin/tls/keystore/*_sk
                    fi;

                    # Generate crypto material for organization peers
                    cd /root/ca-tools/${ORG_NAME_EXT} 
                    if [ "$ADD_PEER" = "false" ]; then
                      ./generate-crypto-peer.sh    
                      break
                    else
                      ./generate-crypto-add-peer.sh  
                      break
                    fi;
                  fi;
                done 

                # Generate crypto material for users     
                for USER in $USERS_IDENTITIES
                do
                  if ([ "$USERS" ] && [ -e  ${MOUNT_PATH}/absent_msp_${USER}.txt ]) || [ "$REFRESH_CERTS" = "true" ]
                  then
                    cd /root/ca-tools/${ORG_NAME_EXT}
                    if [ -z "$USERS_ANSIBLE" ];
                    then 
                      ./generate-user-crypto.sh peer ${USERS}
                    else 
                      ./generate-user-crypto.sh peer ${USERS_ANSIBLE}
                    fi
                    break
                  fi;
                done
              fi;

              # this command creates the indicator of the completion of scripts
              touch ${MOUNT_PATH}/flag_finish.txt
              tail -f /dev/null
          volumeMounts:
          - name: ca-tools-pv
            mountPath: /root/ca-tools
          - name: ca-tools-crypto-pv
            mountPath: /crypto-config
          - name: certcheck
            mountPath: /certcheck
          - name: generate-crypto
            mountPath: /root/ca-tools/{{ $.Values.orgData.orgName }}/generate-crypto-orderer.sh
            subPath: generate-crypto-orderer.sh
          - name: generate-orderer-crypto
            mountPath: /root/ca-tools/{{ $.Values.orgData.orgName }}/orderer-script.sh
            subPath: orderer-script.sh
          - name: generate-crypto-peer
            mountPath: /root/ca-tools/{{ $.Values.orgData.orgName }}/generate-crypto-peer.sh
            subPath: generate-crypto-peer.sh
          - name: generate-crypto-add-peer
            mountPath: /root/ca-tools/{{ $.Values.orgData.orgName }}/generate-crypto-add-peer.sh
            subPath: generate-crypto-add-peer.sh
          - name: generate-user-crypto
            mountPath: /root/ca-tools/{{ $.Values.orgData.orgName }}/generate-user-crypto.sh
            subPath: generate-user-crypto.sh
          - name: package-manager
            mountPath: /scripts/package-manager.sh
            subPath: package-manager.sh
        - name: store-vault
          image: {{ $.Values.image.alpineUtils }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          env:
          - name: VAULT_ADDR
            value: {{ $.Values.global.vault.address }}
          - name: VAULT_APP_ROLE
            value: {{ $.Values.global.vault.role }}
          - name: KUBERNETES_AUTH_PATH
            value: {{ $.Values.global.vault.authPath }}
          - name: VAULT_TYPE
            value: {{ $.Values.global.vault.type }}
          - name: VAULT_SECRET_ENGINE
            value: "{{ .Values.global.vault.secretEngine }}"
          - name: VAULT_SECRET_PREFIX
            value: "{{ .Values.global.vault.secretPrefix }}"
          - name: ORG_NAME_EXT
            value: {{ $.Values.orgData.orgName }}
          - name: COMPONENT_TYPE
            value: {{ $.Values.orgData.type }}
          - name: COMPONENT_NAME
            value: {{ .Release.Namespace }}
          - name: REFRESH_CERTS
            value: "{{ $.Values.checks.refreshCertValue }}"
          - name: PROXY
            value: {{ .Values.global.proxy.provider }}
          - name: EXTERNAL_URL_SUFFIX
            value: {{ .Values.global.proxy.externalUrlSuffix }}
          - name: ORDERERS_NAMES
            value: "{{ $.Values.orderers | join " " -}}"
          - name: PEERS_NAMES
            value: "{{ $.Values.peers | join " " -}}"
          - name: USERS_IDENTITIES
            value: "{{ $.Values.users.usersIdentities | join " " -}}"
          - name: MOUNT_PATH
            value: "/certcheck" 
          command: ["sh", "-c"]
          args:
            - |-
              . /scripts/package-manager.sh
              # Define the packages to install
              packages_to_install="jq curl bash kubectl"
              install_packages "$packages_to_install"

              while ! [ -f ${MOUNT_PATH}/flag_finish.txt ]
              do
                echo 'Waiting for completion of scripts'
                sleep 2s
              done

              ls
              if [ -e /${MOUNT_PATH}/flag_finish.txt ]; then
                if [ "$COMPONENT_TYPE" = "orderer" ]; then
                  # Generate crypto material for organization orderers
                  cd /scripts/orderer
                  ./store-vault-orderer.sh
                fi;

                if [ "$COMPONENT_TYPE" = "peer" ]; then
                  # Generate crypto material for organization peers
                  cd /scripts/peer
                  ./store-vault-peer.sh
                  if [ "$USERS_IDENTITIES" ]
                  then
                    cd /scripts/peer
                    ./store-vault-users.sh
                  fi;    
                fi;
              fi;

              # Raises an error if any certificate has not been stored correctly
              if [ -e /certcheck/certs_not_found.txt ]; then
                exit 1
              fi
              tail -f /dev/null
          volumeMounts:
          - name: ca-tools-pv
            mountPath: /root/ca-tools
          - name: ca-tools-crypto-pv
            mountPath: /crypto-config
          - name: certcheck
            mountPath: /certcheck
          - name: store-vault-orderer
            mountPath: /scripts/orderer/store-vault-orderer.sh
            subPath: store-vault-orderer.sh
          - name: store-vault-peer
            mountPath: /scripts/peer/store-vault-peer.sh
            subPath: store-vault-peer.sh
          - name: store-vault-users
            mountPath: /scripts/peer/store-vault-users.sh
            subPath: store-vault-users.sh
          {{ if and (eq $.Values.orgData.type "peer") (ne $.Values.global.proxy.provider "none") }}
          - name: no-none-config
            mountPath: /crypto-config/peerOrganizations/{{ .Release.Namespace }}/msp/config.yaml
            subPath: no-none-config.yaml
          {{ end }}
          {{ if and (eq $.Values.orgData.type "peer") (eq $.Values.global.proxy.provider "none") }}
          - name: none-config
            mountPath: /crypto-config/peerOrganizations/{{ .Release.Namespace }}/msp/config.yaml
            subPath: none-config.yaml
          {{ end }}
          {{- $file := .Files.Get "files/orderer.crt" }}
          {{ if and (eq $.Values.orgData.type "peer") $file }}
          - name: orderer-tls-cacert
            mountPath: /tlscerts/orderer.crt
            subPath: orderer.crt
          {{- end }}
          - name: package-manager
            mountPath: /scripts/package-manager.sh
            subPath: package-manager.sh
          - name: scripts-volume
            mountPath: /scripts/bevel-vault.sh
            subPath: bevel-vault.sh
